mod handler;
mod protocol;

use libp2p_core::connection::ConnectionId;
use libp2p_core::{Multiaddr, PeerId};
use libp2p_swarm::{NetworkBehaviour, NetworkBehaviourAction, PollParameters};
use std::collections::VecDeque;
use std::task::{Context, Poll};

//
// pub struct Rendezvous {
//     #[behaviour(ignore)]
//     events: VecDeque<RendezvousEvent>,
// }
//
// /// Event generated by the `Ping` network behaviour.
// #[derive(Debug)]
// pub struct RendezvousEvent {
//     /// The peer ID of the remote.
//     pub peer: PeerId,
// }
//
// impl Rendezvous {
//     /// Creates a new `Ping` network behaviour with the given configuration.
//     pub fn new() -> Self {
//         Self {
//             events: VecDeque::new(),
//         }
//     }
// }
//
// impl Default for Rendezvous {
//     fn default() -> Self {
//         Rendezvous::new()
//     }
// }
//
// impl NetworkBehaviour for Rendezvous {
//     type ProtocolsHandler = RendezvousHandler;
//     type OutEvent = RendezvousEvent;
//
//     fn new_handler(&mut self) -> Self::ProtocolsHandler {
//         RendezvousHandler::new()
//     }
//
//     fn addresses_of_peer(&mut self, _peer_id: &PeerId) -> Vec<Multiaddr> {
//         Vec::new()
//     }
//
//     fn inject_connected(&mut self, _: &PeerId) {}
//
//     fn inject_disconnected(&mut self, _: &PeerId) {}
//
//     fn inject_event(&mut self, peer: PeerId, _: ConnectionId, result: PingResult) {
//         self.events.push_front(RendezvousEvent { peer })
//     }
//
//     fn poll(
//         &mut self,
//         _: &mut Context<'_>,
//         _: &mut impl PollParameters,
//     ) -> Poll<NetworkBehaviourAction<Void, RendezvousEvent>> {
//         if let Some(e) = self.events.pop_back() {
//             Poll::Ready(NetworkBehaviourAction::GenerateEvent(e))
//         } else {
//             Poll::Pending
//         }
//     }
// }
